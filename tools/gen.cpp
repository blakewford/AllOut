#include <sstream>
#include <fstream>
#include <iostream>
#include <string.h>
#include <cmath>

#include <vector>
#include <unordered_map>

#include "bmpconstants.h"
#include "../engine/color.h"

const char* DEFAULT_MODEL = "../assets/car.stl";

int32_t cachedArgc = 0;
char argvStorage[1024];
char* cachedArgv[64];

void printHeader()
{
    printf("#pragma once\n\n");
    printf("//AUTOGENERATED FILE WARNING!!!!!\n\n");
    printf("#ifdef __AVR__\n#include <avr/pgmspace.h>\n#endif\n\n");
}

void uncompressed()
{
    std::ifstream sample(cachedArgc > 1 ? cachedArgv[1]: DEFAULT_MODEL);

    printHeader();
    printf("const float PROGMEM obj[] =\n{\n");

    std::vector<float> verts;

    std::string line;
    while(std::getline(sample, line))
    {
        std::istringstream iss(line);
        if(line.find("vertex") != std::string::npos)
        {
            char stlSyntax[32];
            strcpy(stlSyntax, line.c_str());

            char* token = strtok(stlSyntax," ");
            token = strtok (nullptr, " "); //Remove word vertex
            while(token != nullptr)
            {
                verts.push_back(atof(token));
                token = strtok(nullptr, " ");
                verts.push_back(atof(token));
                token = strtok(nullptr, " ");
                verts.push_back(atof(token));
                token = strtok(nullptr, " ");
            }
        }
    }

    printf("    %.2f,\n", (float)verts.size()/3);
    for(std::vector<float>::iterator iter = verts.begin(); iter != verts.end();)
    {
        printf("    %.2f,", *iter++);
        printf("    %.2f,", *iter++);
        printf("    %.2f,\n", *iter++);
    }

    printf("};");
}

int32_t compressed()
{
    int size = 0;
    std::ifstream sample(cachedArgc > 1 ? cachedArgv[1]: DEFAULT_MODEL);

    printHeader();
    printf("const uint8_t PROGMEM obj[] =\n{\n");

    int32_t ndx = 1; //Save space for size
    std::vector<float> verts;
    std::unordered_map<float, uint8_t> values;

    std::string line;
    while(std::getline(sample, line))
    {
        std::istringstream iss(line);
        if(line.find("vertex") != std::string::npos)
        {
            char stlSyntax[32];
            strcpy(stlSyntax, line.c_str());

            char* token = strtok(stlSyntax," ");
            token = strtok (nullptr, " "); //Remove word vertex
            while(token != nullptr)
            {
                auto result = values.insert(std::make_pair<float, uint8_t>(atof(token), ndx));
                verts.push_back(result.first->second);
                if(result.second) ndx++;
                token = strtok(nullptr, " ");

                result = values.insert(std::make_pair<float, uint8_t>(atof(token), ndx));
                verts.push_back(result.first->second);
                if(result.second) ndx++;
                token = strtok(nullptr, " ");

                result = values.insert(std::make_pair<float, uint8_t>(atof(token), ndx));
                verts.push_back(result.first->second);
                if(result.second) ndx++;
                token = strtok(nullptr, " ");
            }
        }
    }

    for(std::vector<float>::iterator iter = verts.begin(); iter != verts.end();)
    {
        printf("    %.0f,", *iter++);
        printf("    %.0f,", *iter++);
        printf("    %.0f,\n", *iter++);
    }

    printf("};");

    ndx = 1; //Reset past size
    size = verts.size()/3;
    printf("\n\nconst float ndxToValue[] =\n{\n    ");
    printf("%.2f, ", (float)verts.size()/3);
    std::unordered_map<float,uint8_t>::iterator iter = values.begin();
    while(values.size() > 0)
    {
        while(iter->second != ndx)
        {
            iter++;
        }

        printf("%.2f, ", iter->first);
        values.erase(iter);
        iter = values.begin();
        ndx++;
    }

    printf("\n};\n");
    return size;
}

void generateTexture(uint8_t* texture, int32_t width, int32_t height)
{
    const int16_t depth = 32;
    const int16_t planes = 1;
    const int32_t offset = 54;
    const int32_t remaining = 40;
    const int32_t resolution = 2835;
    const int32_t dataSize = ((width*height)*4);
    const int32_t headerHeight = -height;

    int32_t size = dataSize + offset;

    texture[BSpace] = 'B';
    texture[MSpace] = 'M';
    memcpy(&texture[BEGINBMPSZ], &size, sizeof(int32_t));
    //Write 0x00 to app specific Space
    memset(&texture[BEGINAPPSPACE], 0, sizeof(int32_t));
    memcpy(&texture[BEGINPXLOFFSET], &offset, sizeof(int32_t));
    memcpy(&texture[BEGINHDRREM], &remaining, sizeof(int32_t));
    memcpy(&texture[BEGINWIDTH], &width, sizeof(int32_t));
    memcpy(&texture[BEGINHEIGHT], &headerHeight, sizeof(int32_t));
    memcpy(&texture[BEGINPLANES], &planes, sizeof(int16_t));
    memcpy(&texture[BEGINDEPTH], &depth, sizeof(int16_t));
    memset(&texture[BEGINBI_RGB], 0, sizeof(int32_t));
    memcpy(&texture[BEGINRAWDATASZ], &dataSize, sizeof(int32_t));
    memcpy(&texture[BEGINHORRES], &resolution, sizeof(int32_t));
    memcpy(&texture[BEGINVERRES], &resolution, sizeof(int32_t));
    memset(&texture[BEGINPALCOLORS], 0, sizeof(int32_t));
    memset(&texture[BEGINIMPCOLORS], 0, sizeof(int32_t));

    int32_t tempHeight = --height;
    while(tempHeight > 0)
    {
        memset(&texture[offset+(tempHeight*width*4)], 0xFF, width*4);
        tempHeight-=5;
    }

    int32_t tempWidth = width-1;
    while(height > 0)
    {
        memset(&texture[offset+(height*width*4)], 0xFF, 4);
        while(tempWidth > 0)
        {
            memset(&texture[offset+(height*width*4)+(tempWidth*4)], 0xFF, 4);
            tempWidth-=5;
        }

        tempWidth = width;
        height--;
    }

    FILE* file = fopen("skin.bmp", "w");
    fwrite(texture, 1, size, file);
    fclose(file);
}

void printBitmapColor(const uint8_t* bitmap, int32_t middle, int32_t dim, int32_t offsetX, int32_t offsetY)
{
    int32_t start = middle + (offsetX*4)*5 + ((dim*4)*offsetY)*5;
    printf("    0x%X,\n", bitmap[start+3] << 16 | bitmap[start+2] << 8 | bitmap[start+1]);
}

void spiral(const uint8_t* bitmap, int32_t middle, int32_t dim, int32_t total)
{
    int32_t offsetX = 0;
    int32_t offsetY = 0;
    int32_t tempX = 1;
    int32_t tempY = 1;

    while(total > 0)
    {
//        printf("RIGHT\n");
        offsetX++;
        tempY--;

        while(total > 0 && tempX <= offsetX)
        {
            printBitmapColor(bitmap, middle, dim, tempX, tempY);
            total--;
            tempX++;
        }

//        printf("UP\n");
        tempX--;
        tempY--;
        offsetY++;
        offsetY = -offsetY;
        while(total > 0 && tempY >= offsetY)
        {
            printBitmapColor(bitmap, middle, dim, tempX, tempY);
            total--;
            tempY--;
        }

//        printf("LEFT\n");

        tempX = offsetX;
        tempX--;
        offsetX++;
        offsetX = -offsetX;
        while(total > 0 && tempX > offsetX)
        {
            printBitmapColor(bitmap, middle, dim, tempX, offsetY);
            total--;
            tempX--;
        }

//        printf("DOWN\n");

        tempX++;
        tempY = offsetY;
        tempY++;
        offsetY = -offsetY;
        offsetY++;
        while(total > 0 && tempY < offsetY)
        {
            printBitmapColor(bitmap, middle, dim, tempX, tempY);
            total--;
            tempY++;
        }
        offsetX = -offsetX;
        offsetX--;
        offsetY--;
        tempX++;
    }
}

int main(int argc, char** argv)
{
    cachedArgc = argc;
    char* storagePointer = argvStorage;
    while(argc--)
    {
        cachedArgv[argc] = storagePointer;
        int32_t length = strlen(argv[argc]);
        strcat(storagePointer, argv[argc]);
        storagePointer+=(length+1);
    }

//    uncompressed();
    int32_t size = compressed();
    const int32_t requiredTiles = size;

    printf("\n");
    printf("const uint8_t PROGMEM fill[] =\n{\n");

    float dim = ceil(sqrt(size)) + 2;
    ((int)dim%2) == 0 ? dim: dim++;
    dim*=5;

    FILE* skin = nullptr;
    if(cachedArgc > 2) skin = fopen(cachedArgv[2],"rb");
    if(skin)
    {
        fseek(skin, 0, SEEK_END);
        int32_t size = ftell(skin);
        rewind(skin);
        uint8_t* binary = (uint8_t*)malloc(size);
        size_t read = fread(binary, 1, size, skin);
        if(read != size) return -1;
        fclose(skin);

        int32_t offsetX = 0;
        int32_t offsetY = 0;
        int32_t pixelOffset = binary[BEGINPXLOFFSET];
        const int32_t middle = ((size - pixelOffset)/2) + pixelOffset + (2*(dim*4)) + (dim*2) + 4;

        spiral(binary, middle, dim, requiredTiles);

        free(binary);
        binary = nullptr;
    }
    else
    {
        int32_t i = 0;
        while(i < size)
        {
            printf("    %d,\n", 0xFF);
            i++;
        }

        int32_t dataSize = 54 + (dim*dim*4);
        uint8_t* texture = new uint8_t[dataSize];

        memset(texture, 0 , dataSize);
        generateTexture(texture, dim, dim);

        delete[] texture;
        texture = nullptr;
    }

    printf("};\n");
}
