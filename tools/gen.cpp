#include <sstream>
#include <fstream>
#include <iostream>
#include <string.h>
#include <cmath>

#include <vector>
#include <algorithm>
#include <unordered_map>

#include "bmpconstants.h"
#include "../engine/color.h"

const char* DEFAULT_MODEL = "../assets/car.stl";

int32_t cachedArgc = 0;
char argvStorage[1024];
char* cachedArgv[64];

struct point
{
    float x;
    float y;
    float z;
};

struct triangle
{
    point* a;
    point* b;
    point* c;

    void clear()
    {
        a = nullptr;
        b = nullptr;
        c = nullptr;
    }
};

bool lowerZOrder(triangle a, triangle b)
{
    return ((a.a->z + a.b->z + a.c->z)/3) < ((b.a->z + b.b->z + b.c->z)/3);
}

float distance(point* a, point* b)
{
    return sqrt(std::pow(b->x-a->x, 2) + std::pow(b->y-a->y, 2) + std::pow(b->z-a->z, 2));
}

int32_t triangleArea(triangle t)
{
    float a = distance(t.a, t.b);
    float b = distance(t.b, t.c);
    float c = distance(t.c, t.a);

    float s = (a+b+c)/2;
    return sqrt(s*(s-a)*(s-b)*(s-c));
}

int32_t reorder(std::vector<float>& verts, std::vector<int32_t>& areas)
{
    int32_t totalArea = 0;

    std::ifstream sample(cachedArgc > 1 ? cachedArgv[1]: DEFAULT_MODEL);
    std::vector<triangle> triangles;

    triangle t;
    std::string line;
    t.clear();

    while(std::getline(sample, line))
    {
        std::istringstream iss(line);
        if(line.find("vertex") != std::string::npos)
        {
            char stlSyntax[32];
            strcpy(stlSyntax, line.c_str());

            char* token = strtok(stlSyntax," ");
            token = strtok (nullptr, " "); //Remove word vertex
            while(token != nullptr)
            {
                point* p = new point();
                p->x = atof(token);
                token = strtok(nullptr, " ");

                p->y = atof(token);
                token = strtok(nullptr, " ");

                p->z = atof(token);
                token = strtok(nullptr, " ");

                if(t.a == nullptr)
                {
                    t.a = p;
                }
                else if(t.b == nullptr)
                {
                    t.b = p;
                }
                else if(t.c == nullptr)
                {
                    t.c = p;
                }
                else
                {
                    triangles.push_back(t);
                    t.clear();
                    t.a = p;
                }
            }
        }
    }

    triangles.push_back(t);
    std::sort(triangles.begin(), triangles.end(), lowerZOrder);

    for(std::vector<triangle>::iterator iter = triangles.begin(); iter != triangles.end(); iter++)
    {
        verts.push_back(iter->a->x);
        verts.push_back(iter->a->y);
        verts.push_back(iter->a->z);
        verts.push_back(iter->b->x);
        verts.push_back(iter->b->y);
        verts.push_back(iter->b->z);
        verts.push_back(iter->c->x);
        verts.push_back(iter->c->y);
        verts.push_back(iter->c->z);

        areas.push_back(triangleArea(*iter));
        totalArea += areas.back();
        printf("%lld\n", totalArea);
    }

    return totalArea;
}

void printHeader()
{
    printf("#pragma once\n\n");
    printf("//AUTOGENERATED FILE WARNING!!!!!\n\n");
    printf("#ifdef __AVR__\n#include <avr/pgmspace.h>\n#endif\n\n");
}

void uncompressed()
{
    std::ifstream sample(cachedArgc > 1 ? cachedArgv[1]: DEFAULT_MODEL);

    printHeader();
    printf("const float PROGMEM obj[] =\n{\n");

    std::vector<float> verts;

    std::string line;
    while(std::getline(sample, line))
    {
        std::istringstream iss(line);
        if(line.find("vertex") != std::string::npos)
        {
            char stlSyntax[32];
            strcpy(stlSyntax, line.c_str());

            char* token = strtok(stlSyntax," ");
            token = strtok (nullptr, " "); //Remove word vertex
            while(token != nullptr)
            {
                verts.push_back(atof(token));
                token = strtok(nullptr, " ");
                verts.push_back(atof(token));
                token = strtok(nullptr, " ");
                verts.push_back(atof(token));
                token = strtok(nullptr, " ");
            }
        }
    }

    printf("    %.2f,\n", (float)verts.size()/3);
    for(std::vector<float>::iterator iter = verts.begin(); iter != verts.end();)
    {
        printf("    %.2f,", *iter++);
        printf("    %.2f,", *iter++);
        printf("    %.2f,\n", *iter++);
    }

    printf("};");
}

int32_t compressed(std::vector<float>& verts)
{
    int size = 0;
    std::ifstream sample(cachedArgc > 1 ? cachedArgv[1]: DEFAULT_MODEL);

    printHeader();
    printf("const uint8_t PROGMEM obj[] =\n{\n");

    int32_t ndx = 1; //Save space for size
    std::vector<float> vertNdx;
    std::unordered_map<float, uint8_t> values;

    for(std::vector<float>::iterator iter = verts.begin(); iter != verts.end(); iter++)
    {
        auto result = values.insert(std::make_pair(*iter, ndx));
        vertNdx.push_back(result.first->second);
        if(result.second) ndx++;
    }

    for(std::vector<float>::iterator iter = vertNdx.begin(); iter != vertNdx.end();)
    {
        printf("    %.0f,", *iter++);
        printf("    %.0f,", *iter++);
        printf("    %.0f,", *iter++);

        printf("\n");
    }

    printf("};");

    ndx = 1; //Reset past size
    size = vertNdx.size()/3;
    printf("\n\nconst float ndxToValue[] =\n{\n    ");
    printf("%.2f, ", (float)size);
    std::unordered_map<float,uint8_t>::iterator iter = values.begin();
    while(values.size() > 0)
    {
        while(iter->second != ndx)
        {
            iter++;
        }

        printf("%.2f, ", iter->first);
        values.erase(iter);
        iter = values.begin();
        ndx++;
    }

    printf("\n};\n");
    return size;
}

void generateTexture(uint8_t* texture, int32_t width, int32_t height)
{
    const int16_t depth = 24;
    const int16_t planes = 1;
    const int32_t offset = 54;
    const int32_t remaining = 40;
    const int32_t resolution = 2835;
    const int32_t dataSize = ((width*height)*3);
    const int32_t headerHeight = -height;

    int32_t size = dataSize + offset;

    texture[BSpace] = 'B';
    texture[MSpace] = 'M';
    memcpy(&texture[BEGINBMPSZ], &size, sizeof(int32_t));
    //Write 0x00 to app specific Space
    memset(&texture[BEGINAPPSPACE], 0, sizeof(int32_t));
    memcpy(&texture[BEGINPXLOFFSET], &offset, sizeof(int32_t));
    memcpy(&texture[BEGINHDRREM], &remaining, sizeof(int32_t));
    memcpy(&texture[BEGINWIDTH], &width, sizeof(int32_t));
    memcpy(&texture[BEGINHEIGHT], &headerHeight, sizeof(int32_t));
    memcpy(&texture[BEGINPLANES], &planes, sizeof(int16_t));
    memcpy(&texture[BEGINDEPTH], &depth, sizeof(int16_t));
    memset(&texture[BEGINBI_RGB], 0, sizeof(int32_t));
    memcpy(&texture[BEGINRAWDATASZ], &dataSize, sizeof(int32_t));
    memcpy(&texture[BEGINHORRES], &resolution, sizeof(int32_t));
    memcpy(&texture[BEGINVERRES], &resolution, sizeof(int32_t));
    memset(&texture[BEGINPALCOLORS], 0, sizeof(int32_t));
    memset(&texture[BEGINIMPCOLORS], 0, sizeof(int32_t));

    int32_t tempHeight = --height;
    while(tempHeight > 0)
    {
//        memset(&texture[offset+(tempHeight*width*4)], 0xFF, width*4);
        tempHeight-=5;
    }

    int32_t tempWidth = width-1;
    while(height > 0)
    {
//        memset(&texture[offset+(height*width*4)], 0xFF, 4);
        while(tempWidth > 0)
        {
 //           memset(&texture[offset+(height*width*4)+(tempWidth*4)], 0xFF, 4);
            tempWidth-=5;
        }

        tempWidth = width;
        height--;
    }

    FILE* file = fopen("skin.bmp", "w");
    fwrite(texture, 1, size, file);
    fclose(file);
}

int main(int argc, char** argv)
{
    cachedArgc = argc;
    char* storagePointer = argvStorage;
    while(argc--)
    {
        cachedArgv[argc] = storagePointer;
        int32_t length = strlen(argv[argc]);
        strcat(storagePointer, argv[argc]);
        storagePointer+=(length+1);
    }

    std::vector<float> verts;
    std::vector<int32_t> areas;
    int32_t area = reorder(verts, areas);

//    uncompressed();
    int32_t size = compressed(verts);
    const int32_t requiredTiles = size;

    printf("\n");
    printf("const uint8_t PROGMEM fill[] =\n{\n");

    int32_t dim = sqrt(area); //Prevent padding with proper alignment
    dim += dim%3;

    FILE* skin = nullptr;
    if(cachedArgc > 2) skin = fopen(cachedArgv[2],"rb");
    if(skin)
    {

    }
    else
    {
        int32_t i = 0;
        while(i < size)
        {
            printf("    %d,\n", 0xFF);
            i++;
        }

        int32_t dataSize = 54 + (dim*dim*3);
        uint8_t* texture = new uint8_t[dataSize];

        memset(texture, 0xFF, dataSize);
        generateTexture(texture, dim, dim);

        delete[] texture;
        texture = nullptr;
    }

    printf("\n");
    printf("const uint8_t PROGMEM order[] =\n{\n");

    int32_t i = 0;
    while(i < size)
    {
        printf("    %d,\n", -1);
        i++;
    }

    printf("};\n");

    printf("\n");
    printf("const uint8_t PROGMEM texture[] =\n{\n");

    i = 0;
    int32_t nextColor = 0;
    while(i < areas.size())
    {
        nextColor += areas[i]*3;
        printf("    %d,\n", nextColor);
        i++;
    }

    printf("};\n");
}
